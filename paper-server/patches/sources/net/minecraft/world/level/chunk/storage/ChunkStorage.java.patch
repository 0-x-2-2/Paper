--- a/net/minecraft/world/level/chunk/storage/ChunkStorage.java
+++ b/net/minecraft/world/level/chunk/storage/ChunkStorage.java
@@ -15,10 +15,16 @@
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.nbt.NbtUtils;
 import net.minecraft.resources.ResourceKey;
+import net.minecraft.server.level.ServerChunkCache;
+import net.minecraft.server.level.ServerLevel;
 import net.minecraft.util.datafix.DataFixTypes;
 import net.minecraft.world.level.ChunkPos;
-import net.minecraft.world.level.Level;
+import net.minecraft.world.level.LevelAccessor;
 import net.minecraft.world.level.chunk.ChunkGenerator;
+// CraftBukkit start
+import java.util.concurrent.ExecutionException;
+import net.minecraft.world.level.chunk.status.ChunkStatus;
+import net.minecraft.world.level.dimension.LevelStem;
 import net.minecraft.world.level.levelgen.structure.LegacyStructureDataHandler;
 import net.minecraft.world.level.storage.DimensionDataStorage;
 
@@ -39,27 +45,86 @@
         return this.worker.isOldChunkAround(chunkPos, checkRadius);
     }
 
-    public CompoundTag upgradeChunkTag(ResourceKey<Level> worldKey, Supplier<DimensionDataStorage> persistentStateManagerFactory, CompoundTag nbt, Optional<ResourceKey<MapCodec<? extends ChunkGenerator>>> generatorCodecKey) {
-        int i = ChunkStorage.getVersion(nbt);
+    // CraftBukkit start
+    private boolean check(ServerChunkCache cps, int x, int z) {
+        if (true) return true; // Paper - Perf: this isn't even needed anymore, light is purged updating to 1.14+, why are we holding up the conversion process reading chunk data off disk - return true, we need to set light populated to true so the converter recognizes the chunk as being "full"
+        ChunkPos pos = new ChunkPos(x, z);
+        if (cps != null) {
+            com.google.common.base.Preconditions.checkState(org.bukkit.Bukkit.isPrimaryThread(), "primary thread");
+            if (cps.hasChunk(x, z)) {
+                return true;
+            }
+        }
 
+        CompoundTag nbt;
+        try {
+            nbt = this.read(pos).get().orElse(null);
+        } catch (InterruptedException | ExecutionException ex) {
+            throw new RuntimeException(ex);
+        }
+        if (nbt != null) {
+            CompoundTag level = nbt.getCompound("Level");
+            if (level.getBoolean("TerrainPopulated")) {
+                return true;
+            }
+
+            ChunkStatus status = ChunkStatus.byName(level.getString("Status"));
+            if (status != null && status.isOrAfter(ChunkStatus.FEATURES)) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    public CompoundTag upgradeChunkTag(ResourceKey<LevelStem> resourcekey, Supplier<DimensionDataStorage> supplier, CompoundTag nbttagcompound, Optional<ResourceKey<MapCodec<? extends ChunkGenerator>>> optional, ChunkPos pos, @Nullable LevelAccessor generatoraccess) {
+        // CraftBukkit end
+        int i = ChunkStorage.getVersion(nbttagcompound);
+
         if (i == SharedConstants.getCurrentVersion().getDataVersion().getVersion()) {
-            return nbt;
+            return nbttagcompound;
         } else {
             try {
+                // CraftBukkit start
+                if (i < 1466) {
+                    CompoundTag level = nbttagcompound.getCompound("Level");
+                    if (level.getBoolean("TerrainPopulated") && !level.getBoolean("LightPopulated")) {
+                        ServerChunkCache cps = (generatoraccess == null) ? null : ((ServerLevel) generatoraccess).getChunkSource();
+                        if (this.check(cps, pos.x - 1, pos.z) && this.check(cps, pos.x - 1, pos.z - 1) && this.check(cps, pos.x, pos.z - 1)) {
+                            level.putBoolean("LightPopulated", true);
+                        }
+                    }
+                }
+                // CraftBukkit end
+
                 if (i < 1493) {
-                    nbt = DataFixTypes.CHUNK.update(this.fixerUpper, nbt, i, 1493);
-                    if (nbt.getCompound("Level").getBoolean("hasLegacyStructureData")) {
-                        LegacyStructureDataHandler persistentstructurelegacy = this.getLegacyStructureHandler(worldKey, persistentStateManagerFactory);
+                    nbttagcompound = DataFixTypes.CHUNK.update(this.fixerUpper, nbttagcompound, i, 1493);
+                    if (nbttagcompound.getCompound("Level").getBoolean("hasLegacyStructureData")) {
+                        LegacyStructureDataHandler persistentstructurelegacy = this.getLegacyStructureHandler(resourcekey, supplier);
 
-                        nbt = persistentstructurelegacy.updateFromLegacy(nbt);
+                        nbttagcompound = persistentstructurelegacy.updateFromLegacy(nbttagcompound);
                     }
                 }
 
-                ChunkStorage.injectDatafixingContext(nbt, worldKey, generatorCodecKey);
-                nbt = DataFixTypes.CHUNK.updateToCurrentVersion(this.fixerUpper, nbt, Math.max(1493, i));
-                ChunkStorage.removeDatafixingContext(nbt);
-                NbtUtils.addCurrentDataVersion(nbt);
-                return nbt;
+                // Spigot start - SPIGOT-6806: Quick and dirty way to prevent below zero generation in old chunks, by setting the status to heightmap instead of empty
+                boolean stopBelowZero = false;
+                boolean belowZeroGenerationInExistingChunks = (generatoraccess != null) ? ((ServerLevel) generatoraccess).spigotConfig.belowZeroGenerationInExistingChunks : org.spigotmc.SpigotConfig.belowZeroGenerationInExistingChunks;
+
+                if (i <= 2730 && !belowZeroGenerationInExistingChunks) {
+                    stopBelowZero = "full".equals(nbttagcompound.getCompound("Level").getString("Status"));
+                }
+                // Spigot end
+
+                ChunkStorage.injectDatafixingContext(nbttagcompound, resourcekey, optional);
+                nbttagcompound = DataFixTypes.CHUNK.updateToCurrentVersion(this.fixerUpper, nbttagcompound, Math.max(1493, i));
+                // Spigot start
+                if (stopBelowZero) {
+                    nbttagcompound.putString("Status", net.minecraft.core.registries.BuiltInRegistries.CHUNK_STATUS.getKey(ChunkStatus.SPAWN).toString());
+                }
+                // Spigot end
+                ChunkStorage.removeDatafixingContext(nbttagcompound);
+                NbtUtils.addCurrentDataVersion(nbttagcompound);
+                return nbttagcompound;
             } catch (Exception exception) {
                 CrashReport crashreport = CrashReport.forThrowable(exception, "Updated chunk");
                 CrashReportCategory crashreportsystemdetails = crashreport.addCategory("Updated chunk details");
@@ -70,7 +135,7 @@
         }
     }
 
-    private LegacyStructureDataHandler getLegacyStructureHandler(ResourceKey<Level> worldKey, Supplier<DimensionDataStorage> stateManagerGetter) {
+    private LegacyStructureDataHandler getLegacyStructureHandler(ResourceKey<LevelStem> worldKey, Supplier<DimensionDataStorage> stateManagerGetter) { // CraftBukkit
         LegacyStructureDataHandler persistentstructurelegacy = this.legacyStructureHandler;
 
         if (persistentstructurelegacy == null) {
@@ -85,7 +150,7 @@
         return persistentstructurelegacy;
     }
 
-    public static void injectDatafixingContext(CompoundTag nbt, ResourceKey<Level> worldKey, Optional<ResourceKey<MapCodec<? extends ChunkGenerator>>> generatorCodecKey) {
+    public static void injectDatafixingContext(CompoundTag nbt, ResourceKey<LevelStem> worldKey, Optional<ResourceKey<MapCodec<? extends ChunkGenerator>>> generatorCodecKey) { // CraftBukkit
         CompoundTag nbttagcompound1 = new CompoundTag();
 
         nbttagcompound1.putString("dimension", worldKey.location().toString());
@@ -108,8 +173,19 @@
     }
 
     public CompletableFuture<Void> write(ChunkPos chunkPos, Supplier<CompoundTag> nbtSupplier) {
+        // Paper start - guard against possible chunk pos desync
+        final Supplier<CompoundTag> guardedPosCheck = () -> {
+            CompoundTag nbt = nbtSupplier.get();
+            if (nbt != null && !chunkPos.equals(SerializableChunkData.getChunkCoordinate(nbt))) {
+                final String world = (ChunkStorage.this instanceof net.minecraft.server.level.ChunkMap) ? ((net.minecraft.server.level.ChunkMap) ChunkStorage.this).level.getWorld().getName() : null;
+                throw new IllegalArgumentException("Chunk coordinate and serialized data do not have matching coordinates, trying to serialize coordinate " + chunkPos
+                    + " but compound says coordinate is " + SerializableChunkData.getChunkCoordinate(nbt) + (world == null ? " for an unknown world" : (" for world: " + world)));
+            }
+            return nbt;
+        };
+        // Paper end - guard against possible chunk pos desync
         this.handleLegacyStructureIndex(chunkPos);
-        return this.worker.store(chunkPos, nbtSupplier);
+        return this.worker.store(chunkPos, guardedPosCheck); // Paper - guard against possible chunk pos desync
     }
 
     protected void handleLegacyStructureIndex(ChunkPos chunkPos) {
