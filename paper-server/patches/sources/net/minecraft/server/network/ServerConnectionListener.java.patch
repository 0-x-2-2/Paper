--- a/net/minecraft/server/network/ServerConnectionListener.java
+++ b/net/minecraft/server/network/ServerConnectionListener.java
@@ -52,22 +52,36 @@
 
     private static final Logger LOGGER = LogUtils.getLogger();
     public static final Supplier<NioEventLoopGroup> SERVER_EVENT_GROUP = Suppliers.memoize(() -> {
-        return new NioEventLoopGroup(0, (new ThreadFactoryBuilder()).setNameFormat("Netty Server IO #%d").setDaemon(true).build());
+        return new NioEventLoopGroup(0, (new ThreadFactoryBuilder()).setNameFormat("Netty Server IO #%d").setDaemon(true).setUncaughtExceptionHandler(new net.minecraft.DefaultUncaughtExceptionHandlerWithName(LOGGER)).build()); // Paper
     });
     public static final Supplier<EpollEventLoopGroup> SERVER_EPOLL_EVENT_GROUP = Suppliers.memoize(() -> {
-        return new EpollEventLoopGroup(0, (new ThreadFactoryBuilder()).setNameFormat("Netty Epoll Server IO #%d").setDaemon(true).build());
+        return new EpollEventLoopGroup(0, (new ThreadFactoryBuilder()).setNameFormat("Netty Epoll Server IO #%d").setDaemon(true).setUncaughtExceptionHandler(new net.minecraft.DefaultUncaughtExceptionHandlerWithName(LOGGER)).build()); // Paper
     });
     final MinecraftServer server;
     public volatile boolean running;
     private final List<ChannelFuture> channels = Collections.synchronizedList(Lists.newArrayList());
     final List<Connection> connections = Collections.synchronizedList(Lists.newArrayList());
+    // Paper start - prevent blocking on adding a new connection while the server is ticking
+    private final java.util.Queue<Connection> pending = new java.util.concurrent.ConcurrentLinkedQueue<>();
+    private final void addPending() {
+        Connection connection;
+        while ((connection = pending.poll()) != null) {
+            connections.add(connection);
+        }
+    }
+    // Paper end - prevent blocking on adding a new connection while the server is ticking
 
     public ServerConnectionListener(MinecraftServer server) {
         this.server = server;
         this.running = true;
     }
 
+    // Paper start - Unix domain socket support
     public void startTcpServerListener(@Nullable InetAddress address, int port) throws IOException {
+        bind(new java.net.InetSocketAddress(address, port));
+    }
+    public void bind(java.net.SocketAddress address) throws IOException {
+    // Paper end - Unix domain socket support
         List list = this.channels;
 
         synchronized (this.channels) {
@@ -75,7 +89,13 @@
             EventLoopGroup eventloopgroup;
 
             if (Epoll.isAvailable() && this.server.isEpollEnabled()) {
+                // Paper start - Unix domain socket support
+                if (address instanceof io.netty.channel.unix.DomainSocketAddress) {
+                    oclass = io.netty.channel.epoll.EpollServerDomainSocketChannel.class;
+                } else {
                 oclass = EpollServerSocketChannel.class;
+                }
+                // Paper end - Unix domain socket support
                 eventloopgroup = (EventLoopGroup) ServerConnectionListener.SERVER_EPOLL_EVENT_GROUP.get();
                 ServerConnectionListener.LOGGER.info("Using epoll channel type");
             } else {
@@ -100,16 +120,28 @@
 
                     Connection.configureSerialization(channelpipeline, PacketFlow.SERVERBOUND, false, (BandwidthDebugMonitor) null);
                     int j = ServerConnectionListener.this.server.getRateLimitPacketsPerSecond();
-                    Object object = j > 0 ? new RateKickingConnection(j) : new Connection(PacketFlow.SERVERBOUND);
+                    Connection object = j > 0 ? new RateKickingConnection(j) : new Connection(PacketFlow.SERVERBOUND); // CraftBukkit - decompile error
 
-                    ServerConnectionListener.this.connections.add(object);
+                    //ServerConnectionListener.this.connections.add(object); // Paper
+                    pending.add(object); // Paper - prevent blocking on adding a new connection while the server is ticking
                     ((Connection) object).configurePacketHandler(channelpipeline);
                     ((Connection) object).setListenerForServerboundHandshake(new ServerHandshakePacketListenerImpl(ServerConnectionListener.this.server, (Connection) object));
+                    io.papermc.paper.network.ChannelInitializeListenerHolder.callListeners(channel); // Paper - Add Channel initialization listeners
                 }
-            }).group(eventloopgroup).localAddress(address, port)).bind().syncUninterruptibly());
+            }).group(eventloopgroup).localAddress(address)).option(ChannelOption.AUTO_READ, false).bind().syncUninterruptibly()); // CraftBukkit // Paper - Unix domain socket support
         }
     }
 
+    // CraftBukkit start
+    public void acceptConnections() {
+        synchronized (this.channels) {
+            for (ChannelFuture future : this.channels) {
+                future.channel().config().setAutoRead(true);
+            }
+        }
+    }
+    // CraftBukkit end
+
     public SocketAddress startMemoryChannel() {
         List list = this.channels;
         ChannelFuture channelfuture;
@@ -153,6 +185,14 @@
         List list = this.connections;
 
         synchronized (this.connections) {
+            // Spigot Start
+            this.addPending(); // Paper - prevent blocking on adding a new connection while the server is ticking
+            // This prevents players from 'gaming' the server, and strategically relogging to increase their position in the tick order
+            if ( org.spigotmc.SpigotConfig.playerShuffle > 0 && MinecraftServer.currentTick % org.spigotmc.SpigotConfig.playerShuffle == 0 )
+            {
+                Collections.shuffle( this.connections );
+            }
+            // Spigot End
             Iterator<Connection> iterator = this.connections.iterator();
 
             while (iterator.hasNext()) {
@@ -176,6 +216,10 @@
                             networkmanager.setReadOnly();
                         }
                     } else {
+                        // Spigot Start
+                        // Fix a race condition where a NetworkManager could be unregistered just before connection.
+                        if (networkmanager.preparing) continue;
+                        // Spigot End
                         iterator.remove();
                         networkmanager.handleDisconnection();
                     }
