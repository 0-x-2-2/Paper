--- a/net/minecraft/server/players/StoredUserList.java
+++ b/net/minecraft/server/players/StoredUserList.java
@@ -30,7 +30,7 @@
     private static final Logger LOGGER = LogUtils.getLogger();
     private static final Gson GSON = (new GsonBuilder()).setPrettyPrinting().create();
     private final File file;
-    private final Map<String, V> map = Maps.newHashMap();
+    private final Map<String, V> map = Maps.newConcurrentMap(); // Paper - Use ConcurrentHashMap in JsonList
 
     public StoredUserList(File file) {
         this.file = file;
@@ -53,8 +53,11 @@
 
     @Nullable
     public V get(K key) {
-        this.removeExpired();
-        return (StoredUserEntry) this.map.get(this.getKeyForUser(key));
+        // Paper start - Use ConcurrentHashMap in JsonList
+        return (V) this.map.computeIfPresent(this.getKeyForUser(key), (k, v) -> {
+            return v.hasExpired() ? null : v;
+        });
+        // Paper end - Use ConcurrentHashMap in JsonList
     }
 
     public void remove(K key) {
@@ -77,7 +80,7 @@
     }
 
     public boolean isEmpty() {
-        return this.map.size() < 1;
+        return this.map.isEmpty(); // Paper - Use ConcurrentHashMap in JsonList
     }
 
     protected String getKeyForUser(K profile) {
@@ -85,29 +88,12 @@
     }
 
     protected boolean contains(K k0) {
+        this.removeExpired(); // CraftBukkit - SPIGOT-7589: Consistently remove expired entries to mirror .get(...)
         return this.map.containsKey(this.getKeyForUser(k0));
     }
 
     private void removeExpired() {
-        List<K> list = Lists.newArrayList();
-        Iterator iterator = this.map.values().iterator();
-
-        while (iterator.hasNext()) {
-            V v0 = (StoredUserEntry) iterator.next();
-
-            if (v0.hasExpired()) {
-                list.add(v0.getUser());
-            }
-        }
-
-        iterator = list.iterator();
-
-        while (iterator.hasNext()) {
-            K k0 = iterator.next();
-
-            this.map.remove(this.getKeyForUser(k0));
-        }
-
+        this.map.values().removeIf(StoredUserEntry::hasExpired); // Paper - Use ConcurrentHashMap in JsonList
     }
 
     protected abstract StoredUserEntry<K> createEntry(JsonObject json);
@@ -117,8 +103,9 @@
     }
 
     public void save() throws IOException {
+        this.removeExpired(); // Paper - remove expired values before saving
         JsonArray jsonarray = new JsonArray();
-        Stream stream = this.map.values().stream().map((jsonlistentry) -> {
+        Stream<JsonObject> stream = this.map.values().stream().map((jsonlistentry) -> { // CraftBukkit - decompile error
             JsonObject jsonobject = new JsonObject();
 
             Objects.requireNonNull(jsonlistentry);
@@ -171,9 +158,17 @@
                         StoredUserEntry<K> jsonlistentry = this.createEntry(jsonobject);
 
                         if (jsonlistentry.getUser() != null) {
-                            this.map.put(this.getKeyForUser(jsonlistentry.getUser()), jsonlistentry);
+                            this.map.put(this.getKeyForUser(jsonlistentry.getUser()), (V) jsonlistentry); // CraftBukkit - decompile error
                         }
                     }
+                // Spigot Start
+                } catch ( com.google.gson.JsonParseException | NullPointerException ex )
+                {
+                    org.bukkit.Bukkit.getLogger().log( java.util.logging.Level.WARNING, "Unable to read file " + this.file + ", backing it up to {0}.backup and creating new copy.", ex );
+                    File backup = new File( this.file + ".backup" );
+                    this.file.renameTo( backup );
+                    this.file.delete();
+                // Spigot End
                 } catch (Throwable throwable) {
                     if (bufferedreader != null) {
                         try {
