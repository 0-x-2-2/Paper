From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Fri, 29 May 2020 20:29:02 -0400
Subject: [PATCH] Synchronize PalettedContainer instead of ReentrantLock

Mojang has flaws in their logic about chunks being concurrently
wrote to. So we constantly see crashes around multiple threads writing.

Additionally, java has optimized synchronization so well that its
in many times faster than trying to manage read wrote locks for low
contention situations.

And this is extremely a low contention situation.

diff --git a/src/main/java/net/minecraft/world/level/chunk/PalettedContainer.java b/src/main/java/net/minecraft/world/level/chunk/PalettedContainer.java
index 0000000000000000000000000000000000000000..0000000000000000000000000000000000000000 100644
--- a/src/main/java/net/minecraft/world/level/chunk/PalettedContainer.java
+++ b/src/main/java/net/minecraft/world/level/chunk/PalettedContainer.java
@@ -0,0 +0,0 @@ public class PalettedContainer<T> implements PaletteResize<T> {
     private final DebugBuffer<Pair<Thread, StackTraceElement[]>> traces = null;
 
     public void acquire() {
+        /* // Paper start - disable this - use proper synchronization
         if (this.traces != null) {
             Thread thread = Thread.currentThread();
             this.traces.push(Pair.of(thread, thread.getStackTrace()));
         }
 
         ThreadingDetector.checkAndLock(this.lock, this.traces, "PalettedContainer");
+        */ // Paper end
     }
 
     public void release() {
-        this.lock.release();
+        //this.lock.release(); // Paper - disable this
     }
 
     public PalettedContainer(Palette<T> fallbackPalette, IdMapper<T> idList, Function<CompoundTag, T> elementDeserializer, Function<T, CompoundTag> elementSerializer, T defaultElement) {
@@ -0,0 +0,0 @@ public class PalettedContainer<T> implements PaletteResize<T> {
         return this.palette.idFor(objectAdded);
     }
 
-    public T getAndSet(int x, int y, int z, T value) {
+    public synchronized T getAndSet(int x, int y, int z, T value) { // Paper - synchronize
         Object var6;
         try {
             this.acquire();
@@ -0,0 +0,0 @@ public class PalettedContainer<T> implements PaletteResize<T> {
         return (T)(object == null ? this.defaultValue : object);
     }
 
-    public void set(int i, int j, int k, T object) {
+    public synchronized void set(int i, int j, int k, T object) { // Paper - synchronize
         try {
             this.acquire();
             this.set(getIndex(i, j, k), object);
@@ -0,0 +0,0 @@ public class PalettedContainer<T> implements PaletteResize<T> {
         return (T)(object == null ? this.defaultValue : object);
     }
 
-    public void read(FriendlyByteBuf buf) {
+    public synchronized void read(FriendlyByteBuf buf) { // Paper - synchronize
         try {
             this.acquire();
             int i = buf.readByte();
@@ -0,0 +0,0 @@ public class PalettedContainer<T> implements PaletteResize<T> {
     }
 
     public void writeDataPaletteBlock(FriendlyByteBuf packetDataSerializer) { this.write(packetDataSerializer); } // Paper - OBFHELPER
-    public void write(FriendlyByteBuf buf) {
+    public synchronized void write(FriendlyByteBuf buf) { // Paper - synchronize
         try {
             this.acquire();
             buf.writeByte(this.bits);
@@ -0,0 +0,0 @@ public class PalettedContainer<T> implements PaletteResize<T> {
 
     }
 
-    public void read(ListTag paletteNbt, long[] data) {
+    public synchronized void read(ListTag paletteNbt, long[] data) { // Paper - synchronize
         try {
             this.acquire();
             int i = Math.max(4, Mth.ceillog2(paletteNbt.size()));
@@ -0,0 +0,0 @@ public class PalettedContainer<T> implements PaletteResize<T> {
 
     }
 
-    public void write(CompoundTag nbt, String paletteKey, String dataKey) {
+    public synchronized void write(CompoundTag nbt, String paletteKey, String dataKey) { // Paper - synchronize
         try {
             this.acquire();
             HashMapPalette<T> hashMapPalette = new HashMapPalette<>(this.registry, this.bits, this.dummyPaletteResize, this.reader, this.writer);
